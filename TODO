+ Add the buffer type.
  (make-buffer initial-size)
  (buffer-size)
  (buffer-append! buffer . items)
    items may be bytes, buffers or strings.
  (buffer->string buffer)

+ Fix Show.
  Strings should be wrapped with "..."
  Any use of show that relied on this, mqo_il_traceback, should be fixed.

+ Add the Alarm API/2
  (timed-alarm time process) -> alarm
    Resumes the specified process some time after timeout 
    milliseconds with 'time

  (alarm-time alarm)
    Returns the time scheduled for a timed alarm.

  (define (recv (<connection> conn))
    (define why (wait (connection-read-alarm conn)
                      (connection-timeout alarm conn)))
    (cond
      (read-alarm? why) (read-descr (connection-descr conn))
      (timeout-alarm? why) <timeout>))

  (alarm-pending? value)
    Returns true if the supplied value is an alarm that has not been
    completed.

  (timed-alarm? value)
    Returns true if the supplied value is a timed-alarm.

+ Add the with special form.
  (with ((...))
    (define (...) ...))

  Translates to (let ((...))
                   (define-global ...))

+ Add the export special form. Make module toplevels bound.

+ Add LAMBDA/2 form
  (lambda/2 name formals . body)
  (ldf ...)
  (ldc "my-lambda-name")
  (ldc 2)
  (ldg set-lambda-name!)
  (call)

+ Alter define to use LAMBDA/2

+ Drop set! hack for naming lambdas.

-------------------------------------------------------------------------------
+  the TRY macro
  (try err
       ((key ...) ...)
       (else ...)
       
       stmt ...)

  expands to
     (guard (lambda err (case (car err) ((key ...) ...) ...))
            stmt ...)

  (try ((key ...) ...)
       (else ...)
    
       stmt ...)

  expands to
     (guard (lambda %err% (case %err% ((key ...) ...) ...)))

-------------------------------------------------------------------------------
+ Devise a Procedure Documentation Format.
  ?? What does it take for arguments?
  ?? Where is it implemented?
  ?? What does it return?
  ?? What errors can it raise?
  ?? What does it do?
  ?? How is it used?

  Ideally, a primitive file would contain all of this.

  (prim id 
    (arg...)
    (ret ...)
    (imp ...))

  A processor would take these expressions and render a primitive.c file
  that can be compiled.

  A processor can also take these expressions and create a manual.

+ Write the source decoration system.
  Each expr in the source code should have an associated line number.
  A modified read primitive returns pairs of line and value.
  An i/o port maintains a line number, and source.

  1: (let ((a 1))
  2:   a)

  ((1 . let)
   (1 . (1. ((1 . a)  (1 . 1))))))

  Only lists need to be decorated by line during read.
  Likewise, only calls need to be decorated by line.

------------------------------------------------------------------------------
+ Write an eval for macros.
  Compile it.
  Assemble it.
  Execute it.
  
  Can assemble be inlined to Compile?
  At least we don't have to bind it.
  The only assemble part that has any logic is the label / addr code.
  We also have the block sorting properties of the lambda code..
  So.. No.

-------------------------------------------------------------------------------

+ Add the let-syntax special form.
  (let-syntax ((syntax-key syntax-fn) ...) stmt ...)

  Caches the current *syntaxes* global, then adds the specified rules on
  a temporary basis.  The statements are expanded using these syntaxes, then
  the syntaxes are removed from the system.

+ Add the define-syntax special form.
  (define-syntax (syntax-key syntax-fn) ...) stmt ...)

  Adds a new syntax to the *syntaxes* global -- only usable from the top level
  of a program.

+ Add the syntax-rules special form.
  (syntax-rules ...)

  Creates a lambda usable by let-syntax and define-syntax.

+ Expand freeze/thaw to add a list type.
  Encodes a sequence of pairs as list, for compression.

+ Expand freeze/thaw to use 1, 2 or 4 bytes for numbers, according to types.
  String, List and Integer types have 1, 2 or 4 byte variants.

+ Expand freeze/thaw/exec/assemble to hard-encode numbers, and booleans.
  ...

+ Expand freeze/thaw to pack symbol data.
  Make symbols case-insensitive restricted to the printable range.
  6 bits per character; is it worth it?

