+ Add LAMBDA/2 form
  (lambda/2 name formals . body)
  (ldf ...)
  (ldc "my-lambda-name")
  (ldc 2)
  (ldg set-lambda-name!)
  (call)

+ Alter define to use LAMBDA/2

+ Drop set! hack for naming lambdas.

-------------------------------------------------------------------------------
+  the TRY macro
  (try err
       ((key ...) ...)
       (else ...)
       
       stmt ...)

  expands to
     (guard (lambda err (case (car err) ((key ...) ...) ...))
            stmt ...)

  (try ((key ...) ...)
       (else ...)
    
       stmt ...)

  expands to
     (guard (lambda %err% (case %err% ((key ...) ...) ...)))

+ Write the source decoration system.
  Each expr in the source code should have an associated line number.
  A modified read primitive returns pairs of line and value.
  An i/o port maintains a line number, and source.

  1: (let ((a 1))
  2:   a)

  ((1 . let)
   (1 . (1. ((1 . a)  (1 . 1))))))

  Only lists need to be decorated by line during read.
  Likewise, only calls need to be decorated by line.

+ Expand freeze/thaw to add a list type.
  Encodes a sequence of pairs as list, for compression.

+ Expand freeze/thaw to use 1, 2 or 4 bytes for numbers, according to types.
  String, List and Integer types have 1, 2 or 4 byte variants.

+ Expand freeze/thaw/exec/assemble to hard-encode numbers, and booleans.
  ...

+ Expand freeze/thaw to pack symbol data.
  Make symbols case-insensitive restricted to the printable range.
  6 bits per character; is it worth it?

