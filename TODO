+ Add the Alarm API.
  (read-alarm descr process) -> alarm
    Resumes the specified process when the supplied descr
    is ready for a read, or closed, with 'read 

  (write-alarm descr process) -> alarm
    Resumes the specified process when the supplied descr
    is ready for a write, or closed, with 'write

  (timed-alarm time process) -> alarm
    Resumes the specified process some time after timeout 
    milliseconds with 'time

  (enable-alarm alarm) -> alarm
    Reactivates the supplied task entry.

  (disable-alarm alarm) -> alarm
    Deactivates the supplied schedule entry, unless it has already been
    completed.

  (alarm? value)
    Returns true if the supplied value is an alarm.

  (alarm-pending? value)
    Returns true if the supplied value is an alarm that has not been
    completed.

  (write-alarm? value)
    Returns true if the supplied value is a write-alarm.

  (read-alarm? value)
    Returns true if the supplied value is a read-alarm.

  (timed-alarm? value)
    Returns true if the supplied value is a timed-alarm.

  (alarm-descr alarm)
    Returns the file descriptor associated with a read or write alarm.

  (alarm-time alarm)
    Returns the time scheduled for a timed alarm.

  (suspend . alarms)
    Suspends the process until one of the alarms specified is signalled.

    (define (recv (<connection> conn))
      (case (suspend (connection-read-alarm conn)
                     (connection-timeout-alarm conn))
        ((read) (read-descr (connection-descr conn)))
        ((timeout) <timeout>)))
    
    Either requires a soft implementation, or processes must be marked with the
    alarms they are waiting on.
    
  Each alarm table is indexed by the FD / time of next exit.

  MQO_BEGIN_TYPE( alarm )
    mqo_byte    task_type;
    union {
        mqo_descr   descr;
        mqo_integer time;
    };
    mqo_process process;
  MQO_END_TYPE( alarm )

  Tasks will not resume processes that are not suspended.
  
  ??? Multiple processes suspended on the same fd??
      Last one wins.

+ Rename file type to descr type.
  (define (recv (<connection> conn) timeout)
    (define to (connection-timeout conn))
    (when to (enable-task to))
    (define tr (connection-reader conn))
    (enable-task tr)
    (case (suspend)
     ((time) <timeout>)
     ((read) (read-descr (connection-descr conn)))
     (else (error 'recv "unrecognized resume of process waiting on packet"))))
                
+ Drop buffer field from read-descr and write-descr.

+ Add the network client layer.
  (make-tcp-client address port) -> conn
  (make-tcp-server address port) -> conn
  (tcp-accept server) -> conn
  (tcp-send conn) -> data
  (tcp-recv conn) -> data
  (tcp-close conn | server) -> data
  (tcp-conn? conn)
  (tcp-server? server)
 
  tcp-recv and tcp-accept will suspend the process instead of blocking 
  when tcp-continue detects that there are no active processes, it will kick
  off a poll of all netwait processes.
 
  tcp-recv -> tcp-wait-recv -> tcp-recv-now
  tcp-accept -> tcp-wait-accept -> tcp-accept-now
  
  tcp-wait-recv
    (suspend-on-fd (conn-fd conn))
  
  fd-to-process 

  At the end of each spin through the processes:
      Iterate over entries in the Timer table, activating all entries
      that should be triggered.
      
      If are any pending processes:
          select timeout will be 0
      Otherwise, if there are no processes waiting on I/O or Timer:
      Otherwise, the timeout will be equal to the time until the first
      entry in the timer table is ready.

      
      Take the lowest timeout from the timer table.. (TAVL 4tw)
      If the timeout has been exceeded, resume that proces

+ Add the with special form.
  (with ((...))
    (define (...) ...))

  Translates to (let ((...))
                   (define-global ...))

+ Add the export special form. Make module toplevels bound.

+ Add LAMBDA/2 form
  (lambda/2 name formals . body)
  (ldf ...)
  (ldc "my-lambda-name")
  (ldc 2)
  (ldg set-lambda-name!)
  (call)

+ Alter define to use LAMBDA/2

+ Drop set! hack for naming lambdas.

-------------------------------------------------------------------------------
+  the TRY macro
  (try err
       ((key ...) ...)
       (else ...)
       
       stmt ...)

  expands to
     (guard (lambda err (case (car err) ((key ...) ...) ...))
            stmt ...)

  (try ((key ...) ...)
       (else ...)
    
       stmt ...)

  expands to
     (guard (lambda %err% (case %err% ((key ...) ...) ...)))

-------------------------------------------------------------------------------
+ Devise a Procedure Documentation Format.
  ?? What does it take for arguments?
  ?? Where is it implemented?
  ?? What does it return?
  ?? What errors can it raise?
  ?? What does it do?
  ?? How is it used?

  Ideally, a primitive file would contain all of this.

  (prim id 
    (arg...)
    (ret ...)
    (imp ...))

  A processor would take these expressions and render a primitive.c file
  that can be compiled.

  A processor can also take these expressions and create a manual.

+ Write the source decoration system.
  Each expr in the source code should have an associated line number.
  A modified read primitive returns pairs of line and value.
  An i/o port maintains a line number, and source.

  1: (let ((a 1))
  2:   a)

  ((1 . let)
   (1 . (1. ((1 . a)  (1 . 1))))))

  Only lists need to be decorated by line during read.
  Likewise, only calls need to be decorated by line.

------------------------------------------------------------------------------
+ Write an eval for macros.
  Compile it.
  Assemble it.
  Execute it.
  
  Can assemble be inlined to Compile?
  At least we don't have to bind it.
  The only assemble part that has any logic is the label / addr code.
  We also have the block sorting properties of the lambda code..
  So.. No.

-------------------------------------------------------------------------------

+ Add the let-syntax special form.
  (let-syntax ((syntax-key syntax-fn) ...) stmt ...)

  Caches the current *syntaxes* global, then adds the specified rules on
  a temporary basis.  The statements are expanded using these syntaxes, then
  the syntaxes are removed from the system.

+ Add the define-syntax special form.
  (define-syntax (syntax-key syntax-fn) ...) stmt ...)

  Adds a new syntax to the *syntaxes* global -- only usable from the top level
  of a program.

+ Add the syntax-rules special form.
  (syntax-rules ...)

  Creates a lambda usable by let-syntax and define-syntax.

+ Expand freeze/thaw to add a list type.
  Encodes a sequence of pairs as list, for compression.

+ Expand freeze/thaw to use 1, 2 or 4 bytes for numbers, according to types.
  String, List and Integer types have 1, 2 or 4 byte variants.

+ Expand freeze/thaw/exec/assemble to hard-encode numbers, and booleans.
  ...

+ Expand freeze/thaw to pack symbol data.
  Make symbols case-insensitive restricted to the printable range.
  6 bits per character; is it worth it?

