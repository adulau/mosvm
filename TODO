+ Write Dispatch
  descriptors have a read_monitor process.
  descriptors have a read_mt method.
  descriptors have a read_data buffer.
  descriptors have a write_data buffer.
  
  mqo_read_mt accepts a descriptor pointer and a context value.
 
  void mqo_write_socket( mqo_socket socket, const char* data, 
                         mqo_word datalen ){

    if( descr.write_data ) == NULL ){
        descr->write_data = mqo_make_buffer( datalen );
    };

    mqo_append_buffer( descr->write_data, data, datalen );
    mqo_add_dispatch( socket ); 
  }
    
  void mqo_read_socket( mqo_socket socket, mqo_process process, 
                        mqo_read_mt read_mt ){

    if( descr.read_data ) == NULL ){
        descr->read_data = mqo_make_buffer( BUFSIZ );
    }else if( descr.read_mt ){
        mqo_errf( mqo_es_os, 
    };
    
    mqo_add_dispatch( socket ); 
  }
  descriptors have a monitor field for use by read_mt
  descriptors have a buffer field for use by write

  the read_mt accepts a descriptor argument, and returns no results.
  the read_mt

+ When a process is halted, it loses its monitor.

+ Add LAMBDA/2 form
  (lambda/2 name formals . body)
  (ldf ...)
  (ldc "my-lambda-name")
  (ldc 2)
  (ldg set-lambda-name!)
  (call)

+ Alter define to use LAMBDA/2

+ Drop set! hack for naming lambdas.

-------------------------------------------------------------------------------
+  the TRY macro
  (try err
       ((key ...) ...)
       (else ...)
       
       stmt ...)

  expands to
     (guard (lambda err (case (car err) ((key ...) ...) ...))
            stmt ...)

  (try ((key ...) ...)
       (else ...)
    
       stmt ...)

  expands to
     (guard (lambda %err% (case %err% ((key ...) ...) ...)))

-------------------------------------------------------------------------------
+ Devise a Procedure Documentation Format.
  ?? What does it take for arguments?
  ?? Where is it implemented?
  ?? What does it return?
  ?? What errors can it raise?
  ?? What does it do?
  ?? How is it used?

  Ideally, a primitive file would contain all of this.

  (prim id 
    (arg...)
    (ret ...)
    (imp ...))

  A processor would take these expressions and render a primitive.c file
  that can be compiled.

  A processor can also take these expressions and create a manual.

+ Write the source decoration system.
  Each expr in the source code should have an associated line number.
  A modified read primitive returns pairs of line and value.
  An i/o port maintains a line number, and source.

  1: (let ((a 1))
  2:   a)

  ((1 . let)
   (1 . (1. ((1 . a)  (1 . 1))))))

  Only lists need to be decorated by line during read.
  Likewise, only calls need to be decorated by line.

+ Expand freeze/thaw to add a list type.
  Encodes a sequence of pairs as list, for compression.

+ Expand freeze/thaw to use 1, 2 or 4 bytes for numbers, according to types.
  String, List and Integer types have 1, 2 or 4 byte variants.

+ Expand freeze/thaw/exec/assemble to hard-encode numbers, and booleans.
  ...

+ Expand freeze/thaw to pack symbol data.
  Make symbols case-insensitive restricted to the printable range.
  6 bits per character; is it worth it?

